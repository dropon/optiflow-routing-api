/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.36
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ReachableAreasAPIService ReachableAreasAPI service
type ReachableAreasAPIService service

type ApiCalculateReachableAreasRequest struct {
	ctx context.Context
	ApiService *ReachableAreasAPIService
	waypoint *string
	horizons *[]int32
	profile *string
	horizonType *HorizonType
	options *ReachableOptions
}

// The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.
func (r ApiCalculateReachableAreasRequest) Waypoint(waypoint string) ApiCalculateReachableAreasRequest {
	r.waypoint = &waypoint
	return r
}

// The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).
func (r ApiCalculateReachableAreasRequest) Horizons(horizons []int32) ApiCalculateReachableAreasRequest {
	r.horizons = &horizons
	return r
}

// A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case.
func (r ApiCalculateReachableAreasRequest) Profile(profile string) ApiCalculateReachableAreasRequest {
	r.profile = &profile
	return r
}

func (r ApiCalculateReachableAreasRequest) HorizonType(horizonType HorizonType) ApiCalculateReachableAreasRequest {
	r.horizonType = &horizonType
	return r
}

// Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options.
func (r ApiCalculateReachableAreasRequest) Options(options ReachableOptions) ApiCalculateReachableAreasRequest {
	r.options = &options
	return r
}

func (r ApiCalculateReachableAreasRequest) Execute() (*ReachableAreas, *http.Response, error) {
	return r.ApiService.CalculateReachableAreasExecute(r)
}

/*
CalculateReachableAreas Method for CalculateReachableAreas

Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCalculateReachableAreasRequest
*/
func (a *ReachableAreasAPIService) CalculateReachableAreas(ctx context.Context) ApiCalculateReachableAreasRequest {
	return ApiCalculateReachableAreasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReachableAreas
func (a *ReachableAreasAPIService) CalculateReachableAreasExecute(r ApiCalculateReachableAreasRequest) (*ReachableAreas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReachableAreas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReachableAreasAPIService.CalculateReachableAreas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reachable-areas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.waypoint == nil {
		return localVarReturnValue, nil, reportError("waypoint is required and must be specified")
	}
	if r.horizons == nil {
		return localVarReturnValue, nil, reportError("horizons is required and must be specified")
	}
	if len(*r.horizons) < 1 {
		return localVarReturnValue, nil, reportError("horizons must have at least 1 elements")
	}
	if len(*r.horizons) > 5 {
		return localVarReturnValue, nil, reportError("horizons must have less than 5 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "waypoint", r.waypoint, "form", "")
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	} else {
		var defaultValue string = "EUR_TRAILER_TRUCK"
		r.profile = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "horizons", r.horizons, "form", "csv")
	if r.horizonType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "horizonType", r.horizonType, "form", "")
	} else {
		var defaultValue HorizonType = "TRAVEL_TIME"
		r.horizonType = &defaultValue
	}
	if r.options != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "options", r.options, "deepObject", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteReachableAreasRequest struct {
	ctx context.Context
	ApiService *ReachableAreasAPIService
	id string
}

func (r ApiDeleteReachableAreasRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteReachableAreasExecute(r)
}

/*
DeleteReachableAreas Method for DeleteReachableAreas

Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the calculated reachable areas.
 @return ApiDeleteReachableAreasRequest
*/
func (a *ReachableAreasAPIService) DeleteReachableAreas(ctx context.Context, id string) ApiDeleteReachableAreasRequest {
	return ApiDeleteReachableAreasRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ReachableAreasAPIService) DeleteReachableAreasExecute(r ApiDeleteReachableAreasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReachableAreasAPIService.DeleteReachableAreas")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reachable-areas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetReachableAreasRequest struct {
	ctx context.Context
	ApiService *ReachableAreasAPIService
	id string
	maximumPollingPeriod *int32
}

// If the calculation is still running, this operation will be blocked and will not return before this period [ms] expires. If the calculation is completed, it will return immediately.  The default of 0 ms will cause the operation to return immediately in any case. Use a value &gt; 0 to implement long polling to reduce the number of requests. See the [tutorial](https://developer.myptv.com/en/resources/tutorials/general/how-use-asynchronous-requests-ptv-developer-apis) on asynchronous requests for details. 
func (r ApiGetReachableAreasRequest) MaximumPollingPeriod(maximumPollingPeriod int32) ApiGetReachableAreasRequest {
	r.maximumPollingPeriod = &maximumPollingPeriod
	return r
}

func (r ApiGetReachableAreasRequest) Execute() (*ReachableAreasResponse, *http.Response, error) {
	return r.ApiService.GetReachableAreasExecute(r)
}

/*
GetReachableAreas Method for GetReachableAreas

Gets the results of a reachable areas calculation specified by its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the calculated reachable areas.
 @return ApiGetReachableAreasRequest
*/
func (a *ReachableAreasAPIService) GetReachableAreas(ctx context.Context, id string) ApiGetReachableAreasRequest {
	return ApiGetReachableAreasRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReachableAreasResponse
func (a *ReachableAreasAPIService) GetReachableAreasExecute(r ApiGetReachableAreasRequest) (*ReachableAreasResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReachableAreasResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReachableAreasAPIService.GetReachableAreas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reachable-areas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maximumPollingPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximumPollingPeriod", r.maximumPollingPeriod, "form", "")
	} else {
		var defaultValue int32 = 0
		r.maximumPollingPeriod = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartAndCreateReachableAreasRequest struct {
	ctx context.Context
	ApiService *ReachableAreasAPIService
	horizons *[]int32
	waypoint *string
	routeId *string
	profile *string
	horizonType *HorizonType
	options *ReachableOptions
}

// The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).
func (r ApiStartAndCreateReachableAreasRequest) Horizons(horizons []int32) ApiStartAndCreateReachableAreasRequest {
	r.horizons = &horizons
	return r
}

// The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.
func (r ApiStartAndCreateReachableAreasRequest) Waypoint(waypoint string) ApiStartAndCreateReachableAreasRequest {
	r.waypoint = &waypoint
	return r
}

// Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/route-ids).
func (r ApiStartAndCreateReachableAreasRequest) RouteId(routeId string) ApiStartAndCreateReachableAreasRequest {
	r.routeId = &routeId
	return r
}

// A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case.
func (r ApiStartAndCreateReachableAreasRequest) Profile(profile string) ApiStartAndCreateReachableAreasRequest {
	r.profile = &profile
	return r
}

func (r ApiStartAndCreateReachableAreasRequest) HorizonType(horizonType HorizonType) ApiStartAndCreateReachableAreasRequest {
	r.horizonType = &horizonType
	return r
}

// Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options.
func (r ApiStartAndCreateReachableAreasRequest) Options(options ReachableOptions) ApiStartAndCreateReachableAreasRequest {
	r.options = &options
	return r
}

func (r ApiStartAndCreateReachableAreasRequest) Execute() (*ReachableAreasId, *http.Response, error) {
	return r.ApiService.StartAndCreateReachableAreasExecute(r)
}

/*
StartAndCreateReachableAreas Method for StartAndCreateReachableAreas

Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStartAndCreateReachableAreasRequest
*/
func (a *ReachableAreasAPIService) StartAndCreateReachableAreas(ctx context.Context) ApiStartAndCreateReachableAreasRequest {
	return ApiStartAndCreateReachableAreasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReachableAreasId
func (a *ReachableAreasAPIService) StartAndCreateReachableAreasExecute(r ApiStartAndCreateReachableAreasRequest) (*ReachableAreasId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReachableAreasId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReachableAreasAPIService.StartAndCreateReachableAreas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reachable-areas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.horizons == nil {
		return localVarReturnValue, nil, reportError("horizons is required and must be specified")
	}
	if len(*r.horizons) < 1 {
		return localVarReturnValue, nil, reportError("horizons must have at least 1 elements")
	}
	if len(*r.horizons) > 5 {
		return localVarReturnValue, nil, reportError("horizons must have less than 5 elements")
	}

	if r.waypoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "waypoint", r.waypoint, "form", "")
	}
	if r.routeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routeId", r.routeId, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	} else {
		var defaultValue string = "EUR_TRAILER_TRUCK"
		r.profile = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "horizons", r.horizons, "form", "csv")
	if r.horizonType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "horizonType", r.horizonType, "form", "")
	} else {
		var defaultValue HorizonType = "TRAVEL_TIME"
		r.horizonType = &defaultValue
	}
	if r.options != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "options", r.options, "deepObject", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
