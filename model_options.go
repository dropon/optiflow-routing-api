/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.33
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow_routing

import (
	"encoding/json"
	"time"
)

// checks if the Options type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Options{}

// Options struct for Options
type Options struct {
	// Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_.  This field is mutually exclusive with **arrivalTime** and **tollTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the start waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
	StartTime *time.Time `json:"startTime,omitempty"`
	// Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This field is mutually exclusive with **startTime** and **tollTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the destination waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
	ArrivalTime *time.Time `json:"arrivalTime,omitempty"`
	// Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with both **startTime** and **arrivalTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
	TollTime    *time.Time   `json:"tollTime,omitempty"`
	TrafficMode *TrafficMode `json:"trafficMode,omitempty"`
	// The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_. Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).   The **warningCode** _ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE_ is returned if the language is not supported for maneuvers.
	Language        *string          `json:"language,omitempty"                     validate:"regexp=[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*"`
	PolylineFormat  *PolylineFormat  `json:"polylineFormat,omitempty"`
	PolylineMapType *PolylineMapType `json:"polylineMapType,omitempty"`
	// Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
	AllowedCountries *string `json:"allowedCountries,omitempty"`
	// Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
	ProhibitedCountries *string `json:"prohibitedCountries,omitempty"`
	// The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).   If it is not specified, the currency is taken from the **profile**.   It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for  toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used  when setting **options[routingMode]=MONETARY**.
	Currency *string `json:"currency,omitempty"                     validate:"regexp=[A-Z]{3}"`
	// Specifies that the route is constructed such that turns to the passenger side are preferred.
	PreferTurnsOnPassengerSide *bool `json:"preferTurnsOnPassengerSide,omitempty"`
	// Comma-separated list of features which should be avoided on the route. Avoided features could be included in a route if there is no possibility to reach the target otherwise. * `TOLL` - Avoid roads with toll. * `FERRIES` - Avoid ferries. Ferries which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _BOAT_. * `RAIL_SHUTTLES` - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _RAIL_. * `HIGHWAYS` - Avoid highways and motorways. Waypoints will not be matched to highways, they will be matched to the nearest road which is not a highway. Cannot be used with **options[routingMode]=MONETARY**.  See [here](./concepts/avoid) for more information.   Available values are provided by type `AvoidFeature`.
	Avoid *string `json:"avoid,omitempty"`
	// Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: `<poly1_lat1>,<poly1_lon1>,...,<poly1_latN>,<poly1_lonN>|<poly2_lat1>,<poly2_lon1>,...,<poly2_latN>,<poly2_lonN>|...`   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments.
	BlockIntersectingRoads *string `json:"blockIntersectingRoads,omitempty"`
	// Comma-separated list of [custom road attribute scenarios](../data-api/concepts/custom-road-attributes) to be considered in the route calculation.  Each scenario can be specified by its name or its ID. A shared scenario can only be specified by its ID.  The size limitations that apply to each scenario, also apply to the collection of scenarios, i.e. the limit  on the number of roads in one scenario can not be circumvented by splitting it in multiple scenarios.
	CustomRoadAttributeScenarios *string      `json:"customRoadAttributeScenarios,omitempty"`
	RoutingMode                  *RoutingMode `json:"routingMode,omitempty"`
	// The maximum speed of the vehicle [km/h]. The speeds for calculating the driving times on all roads will be limited to this value.  See [here](./concepts/speeds) for more information.
	MaximumSpeed *int32 `json:"maximumSpeed,omitempty"`
	// An additional factor to apply to the speed of the vehicle. This modified speed is used to modify the driving times after the route has been calculated. That means in particular that the route itself will not be modified by applying a speed factor. When lower than one, the driving time of the vehicle will increase, when greater than one, the driving time of the vehicle will decrease. Note that the factor is only applied on the parts of the route where the vehicle is driving. Therefore, a speed factor of 1.1 does not necessarily mean that the **travelTime** of the resulting route will be 10% faster. The speed is not capped by the maximum speed of the  vehicle or of the road.  See [here](./concepts/speeds) for more information.
	SpeedFactor *float64 `json:"speedFactor,omitempty"`
}

// NewOptions instantiates a new Options object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewOptions() *Options {
	this := Options{}
	var trafficMode TrafficMode = TRAFFIC_MODE_REALISTIC
	this.TrafficMode = &trafficMode
	var language string = "en"
	this.Language = &language
	var polylineFormat PolylineFormat = GEO_JSON
	this.PolylineFormat = &polylineFormat
	var polylineMapType PolylineMapType = RASTER
	this.PolylineMapType = &polylineMapType
	var preferTurnsOnPassengerSide bool = false
	this.PreferTurnsOnPassengerSide = &preferTurnsOnPassengerSide
	var routingMode RoutingMode = FAST
	this.RoutingMode = &routingMode
	var speedFactor float64 = 1
	this.SpeedFactor = &speedFactor
	return &this
}

// NewOptionsWithDefaults instantiates a new Options object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewOptionsWithDefaults() *Options {
	this := Options{}
	var trafficMode TrafficMode = TRAFFIC_MODE_REALISTIC
	this.TrafficMode = &trafficMode
	var language string = "en"
	this.Language = &language
	var polylineFormat PolylineFormat = GEO_JSON
	this.PolylineFormat = &polylineFormat
	var polylineMapType PolylineMapType = RASTER
	this.PolylineMapType = &polylineMapType
	var preferTurnsOnPassengerSide bool = false
	this.PreferTurnsOnPassengerSide = &preferTurnsOnPassengerSide
	var routingMode RoutingMode = FAST
	this.RoutingMode = &routingMode
	var speedFactor float64 = 1
	this.SpeedFactor = &speedFactor
	return &this
}

// GetStartTime returns the StartTime field value if set, zero value otherwise.
func (o *Options) GetStartTime() time.Time {
	if o == nil || IsNil(o.StartTime) {
		var ret time.Time
		return ret
	}
	return *o.StartTime
}

// GetStartTimeOk returns a tuple with the StartTime field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetStartTimeOk() (*time.Time, bool) {
	if o == nil || IsNil(o.StartTime) {
		return nil, false
	}
	return o.StartTime, true
}

// HasStartTime returns a boolean if a field has been set.
func (o *Options) HasStartTime() bool {
	if o != nil && !IsNil(o.StartTime) {
		return true
	}

	return false
}

// SetStartTime gets a reference to the given time.Time and assigns it to the StartTime field.
func (o *Options) SetStartTime(v time.Time) {
	o.StartTime = &v
}

// GetArrivalTime returns the ArrivalTime field value if set, zero value otherwise.
func (o *Options) GetArrivalTime() time.Time {
	if o == nil || IsNil(o.ArrivalTime) {
		var ret time.Time
		return ret
	}
	return *o.ArrivalTime
}

// GetArrivalTimeOk returns a tuple with the ArrivalTime field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetArrivalTimeOk() (*time.Time, bool) {
	if o == nil || IsNil(o.ArrivalTime) {
		return nil, false
	}
	return o.ArrivalTime, true
}

// HasArrivalTime returns a boolean if a field has been set.
func (o *Options) HasArrivalTime() bool {
	if o != nil && !IsNil(o.ArrivalTime) {
		return true
	}

	return false
}

// SetArrivalTime gets a reference to the given time.Time and assigns it to the ArrivalTime field.
func (o *Options) SetArrivalTime(v time.Time) {
	o.ArrivalTime = &v
}

// GetTollTime returns the TollTime field value if set, zero value otherwise.
func (o *Options) GetTollTime() time.Time {
	if o == nil || IsNil(o.TollTime) {
		var ret time.Time
		return ret
	}
	return *o.TollTime
}

// GetTollTimeOk returns a tuple with the TollTime field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetTollTimeOk() (*time.Time, bool) {
	if o == nil || IsNil(o.TollTime) {
		return nil, false
	}
	return o.TollTime, true
}

// HasTollTime returns a boolean if a field has been set.
func (o *Options) HasTollTime() bool {
	if o != nil && !IsNil(o.TollTime) {
		return true
	}

	return false
}

// SetTollTime gets a reference to the given time.Time and assigns it to the TollTime field.
func (o *Options) SetTollTime(v time.Time) {
	o.TollTime = &v
}

// GetTrafficMode returns the TrafficMode field value if set, zero value otherwise.
func (o *Options) GetTrafficMode() TrafficMode {
	if o == nil || IsNil(o.TrafficMode) {
		var ret TrafficMode
		return ret
	}
	return *o.TrafficMode
}

// GetTrafficModeOk returns a tuple with the TrafficMode field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetTrafficModeOk() (*TrafficMode, bool) {
	if o == nil || IsNil(o.TrafficMode) {
		return nil, false
	}
	return o.TrafficMode, true
}

// HasTrafficMode returns a boolean if a field has been set.
func (o *Options) HasTrafficMode() bool {
	if o != nil && !IsNil(o.TrafficMode) {
		return true
	}

	return false
}

// SetTrafficMode gets a reference to the given TrafficMode and assigns it to the TrafficMode field.
func (o *Options) SetTrafficMode(v TrafficMode) {
	o.TrafficMode = &v
}

// GetLanguage returns the Language field value if set, zero value otherwise.
func (o *Options) GetLanguage() string {
	if o == nil || IsNil(o.Language) {
		var ret string
		return ret
	}
	return *o.Language
}

// GetLanguageOk returns a tuple with the Language field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetLanguageOk() (*string, bool) {
	if o == nil || IsNil(o.Language) {
		return nil, false
	}
	return o.Language, true
}

// HasLanguage returns a boolean if a field has been set.
func (o *Options) HasLanguage() bool {
	if o != nil && !IsNil(o.Language) {
		return true
	}

	return false
}

// SetLanguage gets a reference to the given string and assigns it to the Language field.
func (o *Options) SetLanguage(v string) {
	o.Language = &v
}

// GetPolylineFormat returns the PolylineFormat field value if set, zero value otherwise.
func (o *Options) GetPolylineFormat() PolylineFormat {
	if o == nil || IsNil(o.PolylineFormat) {
		var ret PolylineFormat
		return ret
	}
	return *o.PolylineFormat
}

// GetPolylineFormatOk returns a tuple with the PolylineFormat field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetPolylineFormatOk() (*PolylineFormat, bool) {
	if o == nil || IsNil(o.PolylineFormat) {
		return nil, false
	}
	return o.PolylineFormat, true
}

// HasPolylineFormat returns a boolean if a field has been set.
func (o *Options) HasPolylineFormat() bool {
	if o != nil && !IsNil(o.PolylineFormat) {
		return true
	}

	return false
}

// SetPolylineFormat gets a reference to the given PolylineFormat and assigns it to the PolylineFormat field.
func (o *Options) SetPolylineFormat(v PolylineFormat) {
	o.PolylineFormat = &v
}

// GetPolylineMapType returns the PolylineMapType field value if set, zero value otherwise.
func (o *Options) GetPolylineMapType() PolylineMapType {
	if o == nil || IsNil(o.PolylineMapType) {
		var ret PolylineMapType
		return ret
	}
	return *o.PolylineMapType
}

// GetPolylineMapTypeOk returns a tuple with the PolylineMapType field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetPolylineMapTypeOk() (*PolylineMapType, bool) {
	if o == nil || IsNil(o.PolylineMapType) {
		return nil, false
	}
	return o.PolylineMapType, true
}

// HasPolylineMapType returns a boolean if a field has been set.
func (o *Options) HasPolylineMapType() bool {
	if o != nil && !IsNil(o.PolylineMapType) {
		return true
	}

	return false
}

// SetPolylineMapType gets a reference to the given PolylineMapType and assigns it to the PolylineMapType field.
func (o *Options) SetPolylineMapType(v PolylineMapType) {
	o.PolylineMapType = &v
}

// GetAllowedCountries returns the AllowedCountries field value if set, zero value otherwise.
func (o *Options) GetAllowedCountries() string {
	if o == nil || IsNil(o.AllowedCountries) {
		var ret string
		return ret
	}
	return *o.AllowedCountries
}

// GetAllowedCountriesOk returns a tuple with the AllowedCountries field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetAllowedCountriesOk() (*string, bool) {
	if o == nil || IsNil(o.AllowedCountries) {
		return nil, false
	}
	return o.AllowedCountries, true
}

// HasAllowedCountries returns a boolean if a field has been set.
func (o *Options) HasAllowedCountries() bool {
	if o != nil && !IsNil(o.AllowedCountries) {
		return true
	}

	return false
}

// SetAllowedCountries gets a reference to the given string and assigns it to the AllowedCountries field.
func (o *Options) SetAllowedCountries(v string) {
	o.AllowedCountries = &v
}

// GetProhibitedCountries returns the ProhibitedCountries field value if set, zero value otherwise.
func (o *Options) GetProhibitedCountries() string {
	if o == nil || IsNil(o.ProhibitedCountries) {
		var ret string
		return ret
	}
	return *o.ProhibitedCountries
}

// GetProhibitedCountriesOk returns a tuple with the ProhibitedCountries field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetProhibitedCountriesOk() (*string, bool) {
	if o == nil || IsNil(o.ProhibitedCountries) {
		return nil, false
	}
	return o.ProhibitedCountries, true
}

// HasProhibitedCountries returns a boolean if a field has been set.
func (o *Options) HasProhibitedCountries() bool {
	if o != nil && !IsNil(o.ProhibitedCountries) {
		return true
	}

	return false
}

// SetProhibitedCountries gets a reference to the given string and assigns it to the ProhibitedCountries field.
func (o *Options) SetProhibitedCountries(v string) {
	o.ProhibitedCountries = &v
}

// GetCurrency returns the Currency field value if set, zero value otherwise.
func (o *Options) GetCurrency() string {
	if o == nil || IsNil(o.Currency) {
		var ret string
		return ret
	}
	return *o.Currency
}

// GetCurrencyOk returns a tuple with the Currency field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetCurrencyOk() (*string, bool) {
	if o == nil || IsNil(o.Currency) {
		return nil, false
	}
	return o.Currency, true
}

// HasCurrency returns a boolean if a field has been set.
func (o *Options) HasCurrency() bool {
	if o != nil && !IsNil(o.Currency) {
		return true
	}

	return false
}

// SetCurrency gets a reference to the given string and assigns it to the Currency field.
func (o *Options) SetCurrency(v string) {
	o.Currency = &v
}

// GetPreferTurnsOnPassengerSide returns the PreferTurnsOnPassengerSide field value if set, zero value otherwise.
func (o *Options) GetPreferTurnsOnPassengerSide() bool {
	if o == nil || IsNil(o.PreferTurnsOnPassengerSide) {
		var ret bool
		return ret
	}
	return *o.PreferTurnsOnPassengerSide
}

// GetPreferTurnsOnPassengerSideOk returns a tuple with the PreferTurnsOnPassengerSide field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetPreferTurnsOnPassengerSideOk() (*bool, bool) {
	if o == nil || IsNil(o.PreferTurnsOnPassengerSide) {
		return nil, false
	}
	return o.PreferTurnsOnPassengerSide, true
}

// HasPreferTurnsOnPassengerSide returns a boolean if a field has been set.
func (o *Options) HasPreferTurnsOnPassengerSide() bool {
	if o != nil && !IsNil(o.PreferTurnsOnPassengerSide) {
		return true
	}

	return false
}

// SetPreferTurnsOnPassengerSide gets a reference to the given bool and assigns it to the PreferTurnsOnPassengerSide field.
func (o *Options) SetPreferTurnsOnPassengerSide(v bool) {
	o.PreferTurnsOnPassengerSide = &v
}

// GetAvoid returns the Avoid field value if set, zero value otherwise.
func (o *Options) GetAvoid() string {
	if o == nil || IsNil(o.Avoid) {
		var ret string
		return ret
	}
	return *o.Avoid
}

// GetAvoidOk returns a tuple with the Avoid field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetAvoidOk() (*string, bool) {
	if o == nil || IsNil(o.Avoid) {
		return nil, false
	}
	return o.Avoid, true
}

// HasAvoid returns a boolean if a field has been set.
func (o *Options) HasAvoid() bool {
	if o != nil && !IsNil(o.Avoid) {
		return true
	}

	return false
}

// SetAvoid gets a reference to the given string and assigns it to the Avoid field.
func (o *Options) SetAvoid(v string) {
	o.Avoid = &v
}

// GetBlockIntersectingRoads returns the BlockIntersectingRoads field value if set, zero value otherwise.
func (o *Options) GetBlockIntersectingRoads() string {
	if o == nil || IsNil(o.BlockIntersectingRoads) {
		var ret string
		return ret
	}
	return *o.BlockIntersectingRoads
}

// GetBlockIntersectingRoadsOk returns a tuple with the BlockIntersectingRoads field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetBlockIntersectingRoadsOk() (*string, bool) {
	if o == nil || IsNil(o.BlockIntersectingRoads) {
		return nil, false
	}
	return o.BlockIntersectingRoads, true
}

// HasBlockIntersectingRoads returns a boolean if a field has been set.
func (o *Options) HasBlockIntersectingRoads() bool {
	if o != nil && !IsNil(o.BlockIntersectingRoads) {
		return true
	}

	return false
}

// SetBlockIntersectingRoads gets a reference to the given string and assigns it to the BlockIntersectingRoads field.
func (o *Options) SetBlockIntersectingRoads(v string) {
	o.BlockIntersectingRoads = &v
}

// GetCustomRoadAttributeScenarios returns the CustomRoadAttributeScenarios field value if set, zero value otherwise.
func (o *Options) GetCustomRoadAttributeScenarios() string {
	if o == nil || IsNil(o.CustomRoadAttributeScenarios) {
		var ret string
		return ret
	}
	return *o.CustomRoadAttributeScenarios
}

// GetCustomRoadAttributeScenariosOk returns a tuple with the CustomRoadAttributeScenarios field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetCustomRoadAttributeScenariosOk() (*string, bool) {
	if o == nil || IsNil(o.CustomRoadAttributeScenarios) {
		return nil, false
	}
	return o.CustomRoadAttributeScenarios, true
}

// HasCustomRoadAttributeScenarios returns a boolean if a field has been set.
func (o *Options) HasCustomRoadAttributeScenarios() bool {
	if o != nil && !IsNil(o.CustomRoadAttributeScenarios) {
		return true
	}

	return false
}

// SetCustomRoadAttributeScenarios gets a reference to the given string and assigns it to the CustomRoadAttributeScenarios field.
func (o *Options) SetCustomRoadAttributeScenarios(v string) {
	o.CustomRoadAttributeScenarios = &v
}

// GetRoutingMode returns the RoutingMode field value if set, zero value otherwise.
func (o *Options) GetRoutingMode() RoutingMode {
	if o == nil || IsNil(o.RoutingMode) {
		var ret RoutingMode
		return ret
	}
	return *o.RoutingMode
}

// GetRoutingModeOk returns a tuple with the RoutingMode field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetRoutingModeOk() (*RoutingMode, bool) {
	if o == nil || IsNil(o.RoutingMode) {
		return nil, false
	}
	return o.RoutingMode, true
}

// HasRoutingMode returns a boolean if a field has been set.
func (o *Options) HasRoutingMode() bool {
	if o != nil && !IsNil(o.RoutingMode) {
		return true
	}

	return false
}

// SetRoutingMode gets a reference to the given RoutingMode and assigns it to the RoutingMode field.
func (o *Options) SetRoutingMode(v RoutingMode) {
	o.RoutingMode = &v
}

// GetMaximumSpeed returns the MaximumSpeed field value if set, zero value otherwise.
func (o *Options) GetMaximumSpeed() int32 {
	if o == nil || IsNil(o.MaximumSpeed) {
		var ret int32
		return ret
	}
	return *o.MaximumSpeed
}

// GetMaximumSpeedOk returns a tuple with the MaximumSpeed field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetMaximumSpeedOk() (*int32, bool) {
	if o == nil || IsNil(o.MaximumSpeed) {
		return nil, false
	}
	return o.MaximumSpeed, true
}

// HasMaximumSpeed returns a boolean if a field has been set.
func (o *Options) HasMaximumSpeed() bool {
	if o != nil && !IsNil(o.MaximumSpeed) {
		return true
	}

	return false
}

// SetMaximumSpeed gets a reference to the given int32 and assigns it to the MaximumSpeed field.
func (o *Options) SetMaximumSpeed(v int32) {
	o.MaximumSpeed = &v
}

// GetSpeedFactor returns the SpeedFactor field value if set, zero value otherwise.
func (o *Options) GetSpeedFactor() float64 {
	if o == nil || IsNil(o.SpeedFactor) {
		var ret float64
		return ret
	}
	return *o.SpeedFactor
}

// GetSpeedFactorOk returns a tuple with the SpeedFactor field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Options) GetSpeedFactorOk() (*float64, bool) {
	if o == nil || IsNil(o.SpeedFactor) {
		return nil, false
	}
	return o.SpeedFactor, true
}

// HasSpeedFactor returns a boolean if a field has been set.
func (o *Options) HasSpeedFactor() bool {
	if o != nil && !IsNil(o.SpeedFactor) {
		return true
	}

	return false
}

// SetSpeedFactor gets a reference to the given float64 and assigns it to the SpeedFactor field.
func (o *Options) SetSpeedFactor(v float64) {
	o.SpeedFactor = &v
}

func (o Options) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Options) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.StartTime) {
		toSerialize["startTime"] = o.StartTime
	}
	if !IsNil(o.ArrivalTime) {
		toSerialize["arrivalTime"] = o.ArrivalTime
	}
	if !IsNil(o.TollTime) {
		toSerialize["tollTime"] = o.TollTime
	}
	if !IsNil(o.TrafficMode) {
		toSerialize["trafficMode"] = o.TrafficMode
	}
	if !IsNil(o.Language) {
		toSerialize["language"] = o.Language
	}
	if !IsNil(o.PolylineFormat) {
		toSerialize["polylineFormat"] = o.PolylineFormat
	}
	if !IsNil(o.PolylineMapType) {
		toSerialize["polylineMapType"] = o.PolylineMapType
	}
	if !IsNil(o.AllowedCountries) {
		toSerialize["allowedCountries"] = o.AllowedCountries
	}
	if !IsNil(o.ProhibitedCountries) {
		toSerialize["prohibitedCountries"] = o.ProhibitedCountries
	}
	if !IsNil(o.Currency) {
		toSerialize["currency"] = o.Currency
	}
	if !IsNil(o.PreferTurnsOnPassengerSide) {
		toSerialize["preferTurnsOnPassengerSide"] = o.PreferTurnsOnPassengerSide
	}
	if !IsNil(o.Avoid) {
		toSerialize["avoid"] = o.Avoid
	}
	if !IsNil(o.BlockIntersectingRoads) {
		toSerialize["blockIntersectingRoads"] = o.BlockIntersectingRoads
	}
	if !IsNil(o.CustomRoadAttributeScenarios) {
		toSerialize["customRoadAttributeScenarios"] = o.CustomRoadAttributeScenarios
	}
	if !IsNil(o.RoutingMode) {
		toSerialize["routingMode"] = o.RoutingMode
	}
	if !IsNil(o.MaximumSpeed) {
		toSerialize["maximumSpeed"] = o.MaximumSpeed
	}
	if !IsNil(o.SpeedFactor) {
		toSerialize["speedFactor"] = o.SpeedFactor
	}
	return toSerialize, nil
}

type NullableOptions struct {
	value *Options
	isSet bool
}

func (v NullableOptions) Get() *Options {
	return v.value
}

func (v *NullableOptions) Set(val *Options) {
	v.value = val
	v.isSet = true
}

func (v NullableOptions) IsSet() bool {
	return v.isSet
}

func (v *NullableOptions) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableOptions(val *Options) *NullableOptions {
	return &NullableOptions{value: val, isSet: true}
}

func (v NullableOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableOptions) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
