/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.33
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow_routing

import (
	"encoding/json"
	"fmt"
)

// ReachableTrafficMode Defines how to consider traffic in a reachable areas or a reachable locations calculation.  * `REALISTIC` - Uses the most realistic **travelTime** and **distance** for the selected vehicle and the  given **referenceTime** (or the current time if none **referenceTime** is specified).  Takes into account the live traffic situation such as traffic jams or road works  as well as the typical traffic situation at the time of day and the day of week of travel such as the rush-hour  on Monday morning or light traffic on Saturday evening.  * `AVERAGE` - Uses the average **travelTime** and **distance** for the selected vehicle.  If **referenceTime** is specified, the typical traffic situation for that time of day and day of week will be considered such as the rush-hour  on Monday morning or light traffic on Saturday evening.  If no **referenceTime** is specified the typical traffic situation will not be considered, and **travelTime** and **distance** are an average independent of when to travel.  See [here](./concepts/traffic-modes) for more information. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.
type ReachableTrafficMode string

// List of ReachableTrafficMode
const (
	REALISTIC ReachableTrafficMode = "REALISTIC"
	AVERAGE ReachableTrafficMode = "AVERAGE"
)

// All allowed values of ReachableTrafficMode enum
var AllowedReachableTrafficModeEnumValues = []ReachableTrafficMode{
	"REALISTIC",
	"AVERAGE",
}

func (v *ReachableTrafficMode) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ReachableTrafficMode(value)
	for _, existing := range AllowedReachableTrafficModeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ReachableTrafficMode", value)
}

// NewReachableTrafficModeFromValue returns a pointer to a valid ReachableTrafficMode
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewReachableTrafficModeFromValue(v string) (*ReachableTrafficMode, error) {
	ev := ReachableTrafficMode(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ReachableTrafficMode: valid values are %v", v, AllowedReachableTrafficModeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ReachableTrafficMode) IsValid() bool {
	for _, existing := range AllowedReachableTrafficModeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ReachableTrafficMode value
func (v ReachableTrafficMode) Ptr() *ReachableTrafficMode {
	return &v
}

type NullableReachableTrafficMode struct {
	value *ReachableTrafficMode
	isSet bool
}

func (v NullableReachableTrafficMode) Get() *ReachableTrafficMode {
	return v.value
}

func (v *NullableReachableTrafficMode) Set(val *ReachableTrafficMode) {
	v.value = val
	v.isSet = true
}

func (v NullableReachableTrafficMode) IsSet() bool {
	return v.isSet
}

func (v *NullableReachableTrafficMode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableReachableTrafficMode(val *ReachableTrafficMode) *NullableReachableTrafficMode {
	return &NullableReachableTrafficMode{value: val, isSet: true}
}

func (v NullableReachableTrafficMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableReachableTrafficMode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

