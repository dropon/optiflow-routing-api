/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.33
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow_routing

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the TollCosts type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TollCosts{}

// TollCosts The toll prices payable for this route or leg aggregated by currency.
type TollCosts struct {
	// The toll prices payable in the given currencies. The price may be 0 if no toll applies for a currency in a country passed by the route.
	Prices []TollPrice `json:"prices"`
	// The cumulated toll price in the converted currency.
	ConvertedPrice *TollPrice `json:"convertedPrice,omitempty"`
	// The toll prices by country or subdivision. The price may be 0 if no toll applies in a country passed by the route.
	Countries []TollCostsByCountry `json:"countries"`
	// True, if the start or destination waypoint is located inside a toll section. In such cases the exact toll price cannot be calculated and the closest toll location after the waypoint is used to approximate the toll price. When toll sections are requested, the affected section is marked as well.
	ContainsApproximatedSections *bool `json:"containsApproximatedSections,omitempty"`
}

type _TollCosts TollCosts

// NewTollCosts instantiates a new TollCosts object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTollCosts(prices []TollPrice, countries []TollCostsByCountry) *TollCosts {
	this := TollCosts{}
	this.Prices = prices
	this.Countries = countries
	return &this
}

// NewTollCostsWithDefaults instantiates a new TollCosts object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTollCostsWithDefaults() *TollCosts {
	this := TollCosts{}
	return &this
}

// GetPrices returns the Prices field value
func (o *TollCosts) GetPrices() []TollPrice {
	if o == nil {
		var ret []TollPrice
		return ret
	}

	return o.Prices
}

// GetPricesOk returns a tuple with the Prices field value
// and a boolean to check if the value has been set.
func (o *TollCosts) GetPricesOk() ([]TollPrice, bool) {
	if o == nil {
		return nil, false
	}
	return o.Prices, true
}

// SetPrices sets field value
func (o *TollCosts) SetPrices(v []TollPrice) {
	o.Prices = v
}

// GetConvertedPrice returns the ConvertedPrice field value if set, zero value otherwise.
func (o *TollCosts) GetConvertedPrice() TollPrice {
	if o == nil || IsNil(o.ConvertedPrice) {
		var ret TollPrice
		return ret
	}
	return *o.ConvertedPrice
}

// GetConvertedPriceOk returns a tuple with the ConvertedPrice field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TollCosts) GetConvertedPriceOk() (*TollPrice, bool) {
	if o == nil || IsNil(o.ConvertedPrice) {
		return nil, false
	}
	return o.ConvertedPrice, true
}

// HasConvertedPrice returns a boolean if a field has been set.
func (o *TollCosts) HasConvertedPrice() bool {
	if o != nil && !IsNil(o.ConvertedPrice) {
		return true
	}

	return false
}

// SetConvertedPrice gets a reference to the given TollPrice and assigns it to the ConvertedPrice field.
func (o *TollCosts) SetConvertedPrice(v TollPrice) {
	o.ConvertedPrice = &v
}

// GetCountries returns the Countries field value
func (o *TollCosts) GetCountries() []TollCostsByCountry {
	if o == nil {
		var ret []TollCostsByCountry
		return ret
	}

	return o.Countries
}

// GetCountriesOk returns a tuple with the Countries field value
// and a boolean to check if the value has been set.
func (o *TollCosts) GetCountriesOk() ([]TollCostsByCountry, bool) {
	if o == nil {
		return nil, false
	}
	return o.Countries, true
}

// SetCountries sets field value
func (o *TollCosts) SetCountries(v []TollCostsByCountry) {
	o.Countries = v
}

// GetContainsApproximatedSections returns the ContainsApproximatedSections field value if set, zero value otherwise.
func (o *TollCosts) GetContainsApproximatedSections() bool {
	if o == nil || IsNil(o.ContainsApproximatedSections) {
		var ret bool
		return ret
	}
	return *o.ContainsApproximatedSections
}

// GetContainsApproximatedSectionsOk returns a tuple with the ContainsApproximatedSections field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TollCosts) GetContainsApproximatedSectionsOk() (*bool, bool) {
	if o == nil || IsNil(o.ContainsApproximatedSections) {
		return nil, false
	}
	return o.ContainsApproximatedSections, true
}

// HasContainsApproximatedSections returns a boolean if a field has been set.
func (o *TollCosts) HasContainsApproximatedSections() bool {
	if o != nil && !IsNil(o.ContainsApproximatedSections) {
		return true
	}

	return false
}

// SetContainsApproximatedSections gets a reference to the given bool and assigns it to the ContainsApproximatedSections field.
func (o *TollCosts) SetContainsApproximatedSections(v bool) {
	o.ContainsApproximatedSections = &v
}

func (o TollCosts) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TollCosts) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["prices"] = o.Prices
	if !IsNil(o.ConvertedPrice) {
		toSerialize["convertedPrice"] = o.ConvertedPrice
	}
	toSerialize["countries"] = o.Countries
	if !IsNil(o.ContainsApproximatedSections) {
		toSerialize["containsApproximatedSections"] = o.ContainsApproximatedSections
	}
	return toSerialize, nil
}

func (o *TollCosts) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"prices",
		"countries",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varTollCosts := _TollCosts{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varTollCosts)

	if err != nil {
		return err
	}

	*o = TollCosts(varTollCosts)

	return err
}

type NullableTollCosts struct {
	value *TollCosts
	isSet bool
}

func (v NullableTollCosts) Get() *TollCosts {
	return v.value
}

func (v *NullableTollCosts) Set(val *TollCosts) {
	v.value = val
	v.isSet = true
}

func (v NullableTollCosts) IsSet() bool {
	return v.isSet
}

func (v *NullableTollCosts) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTollCosts(val *TollCosts) *NullableTollCosts {
	return &NullableTollCosts{value: val, isSet: true}
}

func (v NullableTollCosts) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTollCosts) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


