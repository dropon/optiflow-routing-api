/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.36
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the TollEvent type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TollEvent{}

// TollEvent Issued when a road subject to toll is entered or exited. Requires _TOLL_EVENTS_ to be requested.
type TollEvent struct {
	// The index of the corresponding toll section.  The section indexes of a pair of ENTER and EXIT events define the range of sections between the two events.
	SectionIndex *int32 `json:"sectionIndex,omitempty"`
	// The display name of the toll event. Only present if a name is available. For example, this name can be a toll location name defined by the toll operator. In some cases the display names of the toll event and the toll section can differ. In case the toll section has been approximated, the display name of the affected toll event contains the hint \"(approximated)\".
	DisplayName *string `json:"displayName,omitempty"`
	AccessType AccessType `json:"accessType"`
	// For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.
	RelatedEventIndex *int32 `json:"relatedEventIndex,omitempty"`
}

type _TollEvent TollEvent

// NewTollEvent instantiates a new TollEvent object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTollEvent(accessType AccessType) *TollEvent {
	this := TollEvent{}
	this.AccessType = accessType
	return &this
}

// NewTollEventWithDefaults instantiates a new TollEvent object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTollEventWithDefaults() *TollEvent {
	this := TollEvent{}
	return &this
}

// GetSectionIndex returns the SectionIndex field value if set, zero value otherwise.
func (o *TollEvent) GetSectionIndex() int32 {
	if o == nil || IsNil(o.SectionIndex) {
		var ret int32
		return ret
	}
	return *o.SectionIndex
}

// GetSectionIndexOk returns a tuple with the SectionIndex field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TollEvent) GetSectionIndexOk() (*int32, bool) {
	if o == nil || IsNil(o.SectionIndex) {
		return nil, false
	}
	return o.SectionIndex, true
}

// HasSectionIndex returns a boolean if a field has been set.
func (o *TollEvent) HasSectionIndex() bool {
	if o != nil && !IsNil(o.SectionIndex) {
		return true
	}

	return false
}

// SetSectionIndex gets a reference to the given int32 and assigns it to the SectionIndex field.
func (o *TollEvent) SetSectionIndex(v int32) {
	o.SectionIndex = &v
}

// GetDisplayName returns the DisplayName field value if set, zero value otherwise.
func (o *TollEvent) GetDisplayName() string {
	if o == nil || IsNil(o.DisplayName) {
		var ret string
		return ret
	}
	return *o.DisplayName
}

// GetDisplayNameOk returns a tuple with the DisplayName field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TollEvent) GetDisplayNameOk() (*string, bool) {
	if o == nil || IsNil(o.DisplayName) {
		return nil, false
	}
	return o.DisplayName, true
}

// HasDisplayName returns a boolean if a field has been set.
func (o *TollEvent) HasDisplayName() bool {
	if o != nil && !IsNil(o.DisplayName) {
		return true
	}

	return false
}

// SetDisplayName gets a reference to the given string and assigns it to the DisplayName field.
func (o *TollEvent) SetDisplayName(v string) {
	o.DisplayName = &v
}

// GetAccessType returns the AccessType field value
func (o *TollEvent) GetAccessType() AccessType {
	if o == nil {
		var ret AccessType
		return ret
	}

	return o.AccessType
}

// GetAccessTypeOk returns a tuple with the AccessType field value
// and a boolean to check if the value has been set.
func (o *TollEvent) GetAccessTypeOk() (*AccessType, bool) {
	if o == nil {
		return nil, false
	}
	return &o.AccessType, true
}

// SetAccessType sets field value
func (o *TollEvent) SetAccessType(v AccessType) {
	o.AccessType = v
}

// GetRelatedEventIndex returns the RelatedEventIndex field value if set, zero value otherwise.
func (o *TollEvent) GetRelatedEventIndex() int32 {
	if o == nil || IsNil(o.RelatedEventIndex) {
		var ret int32
		return ret
	}
	return *o.RelatedEventIndex
}

// GetRelatedEventIndexOk returns a tuple with the RelatedEventIndex field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TollEvent) GetRelatedEventIndexOk() (*int32, bool) {
	if o == nil || IsNil(o.RelatedEventIndex) {
		return nil, false
	}
	return o.RelatedEventIndex, true
}

// HasRelatedEventIndex returns a boolean if a field has been set.
func (o *TollEvent) HasRelatedEventIndex() bool {
	if o != nil && !IsNil(o.RelatedEventIndex) {
		return true
	}

	return false
}

// SetRelatedEventIndex gets a reference to the given int32 and assigns it to the RelatedEventIndex field.
func (o *TollEvent) SetRelatedEventIndex(v int32) {
	o.RelatedEventIndex = &v
}

func (o TollEvent) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TollEvent) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.SectionIndex) {
		toSerialize["sectionIndex"] = o.SectionIndex
	}
	if !IsNil(o.DisplayName) {
		toSerialize["displayName"] = o.DisplayName
	}
	toSerialize["accessType"] = o.AccessType
	if !IsNil(o.RelatedEventIndex) {
		toSerialize["relatedEventIndex"] = o.RelatedEventIndex
	}
	return toSerialize, nil
}

func (o *TollEvent) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"accessType",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varTollEvent := _TollEvent{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varTollEvent)

	if err != nil {
		return err
	}

	*o = TollEvent(varTollEvent)

	return err
}

type NullableTollEvent struct {
	value *TollEvent
	isSet bool
}

func (v NullableTollEvent) Get() *TollEvent {
	return v.value
}

func (v *NullableTollEvent) Set(val *TollEvent) {
	v.value = val
	v.isSet = true
}

func (v NullableTollEvent) IsSet() bool {
	return v.isSet
}

func (v *NullableTollEvent) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTollEvent(val *TollEvent) *NullableTollEvent {
	return &NullableTollEvent{value: val, isSet: true}
}

func (v NullableTollEvent) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTollEvent) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


