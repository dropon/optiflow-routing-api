/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.33
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow_routing

import (
	"encoding/json"
	"fmt"
)

// TollRoadType The reason why toll is charged.    * `GENERAL` - A general toll road where no special toll applies.    * `CITY` - An urban area or city is subject to toll.    * `BRIDGE` - A bridge is subject to toll.    * `TUNNEL` - A tunnel is subject to toll.    * `FERRY` - A ferry is subject to toll.    * `MOUNTAIN_PASS` - A mountain pass is subject to toll.  
type TollRoadType string

// List of TollRoadType
const (
	GENERAL TollRoadType = "GENERAL"
	CITY TollRoadType = "CITY"
	BRIDGE TollRoadType = "BRIDGE"
	TUNNEL TollRoadType = "TUNNEL"
	FERRY TollRoadType = "FERRY"
	MOUNTAIN_PASS TollRoadType = "MOUNTAIN_PASS"
)

// All allowed values of TollRoadType enum
var AllowedTollRoadTypeEnumValues = []TollRoadType{
	"GENERAL",
	"CITY",
	"BRIDGE",
	"TUNNEL",
	"FERRY",
	"MOUNTAIN_PASS",
}

func (v *TollRoadType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := TollRoadType(value)
	for _, existing := range AllowedTollRoadTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid TollRoadType", value)
}

// NewTollRoadTypeFromValue returns a pointer to a valid TollRoadType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewTollRoadTypeFromValue(v string) (*TollRoadType, error) {
	ev := TollRoadType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for TollRoadType: valid values are %v", v, AllowedTollRoadTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v TollRoadType) IsValid() bool {
	for _, existing := range AllowedTollRoadTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to TollRoadType value
func (v TollRoadType) Ptr() *TollRoadType {
	return &v
}

type NullableTollRoadType struct {
	value *TollRoadType
	isSet bool
}

func (v NullableTollRoadType) Get() *TollRoadType {
	return v.value
}

func (v *NullableTollRoadType) Set(val *TollRoadType) {
	v.value = val
	v.isSet = true
}

func (v NullableTollRoadType) IsSet() bool {
	return v.isSet
}

func (v *NullableTollRoadType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTollRoadType(val *TollRoadType) *NullableTollRoadType {
	return &NullableTollRoadType{value: val, isSet: true}
}

func (v NullableTollRoadType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTollRoadType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

