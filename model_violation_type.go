/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.36
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// ViolationType The reason why the road or the schedule is violated.  * `PROHIBITED` - The violated road is prohibited in general for the current vehicle such as some roads in city centers, parks, forests and farmland or it is temporarily closed due to construction sites.    * `DELIVERY_ONLY` - The violated road is prohibited except for delivery vehicles such as factory premises or pedestrian zones. Cars and vans are no delivery vehicles and may produce such violations.    * `URBAN` - The violated road is prohibited because urban roads are prohibited for the current vehicle. This will not happen for the predefined profiles.    * `RESIDENTS_ONLY` - The violated road is prohibited because roads flagged as residents only are prohibited for the current vehicle. This will not happen for the predefined profiles.  * `RESTRICTED_ACCESS` - The violated road is prohibited because it has restricted access because a gate or a bollard has to be passed. This will always have **accessType** _PASS_.    * `VEHICLE_PROPERTY` - The violated road is prohibited for the current vehicle as some vehicle property exceeds a limit such as the weight or height, or the road is prohibited for trucks in general.    * `COMBINED_TRANSPORT` - The violated road is a boat (ferry) or rail (train or rail shuttle) connection prohibited for the current vehicle.  * `SCHEDULE` - The schedule is violated. The reasons can be found in **scheduleViolationTypes**.  * `BLOCKED_ROAD_BY_INTERSECTION` - The violated road has been blocked through **options[blockIntersectingRoads]**.
type ViolationType string

// List of ViolationType
const (
	PROHIBITED ViolationType = "PROHIBITED"
	DELIVERY_ONLY ViolationType = "DELIVERY_ONLY"
	URBAN ViolationType = "URBAN"
	RESIDENTS_ONLY ViolationType = "RESIDENTS_ONLY"
	RESTRICTED_ACCESS ViolationType = "RESTRICTED_ACCESS"
	VEHICLE_PROPERTY ViolationType = "VEHICLE_PROPERTY"
	COMBINED_TRANSPORT ViolationType = "COMBINED_TRANSPORT"
	SCHEDULE ViolationType = "SCHEDULE"
	BLOCKED_ROAD_BY_INTERSECTION ViolationType = "BLOCKED_ROAD_BY_INTERSECTION"
)

// All allowed values of ViolationType enum
var AllowedViolationTypeEnumValues = []ViolationType{
	"PROHIBITED",
	"DELIVERY_ONLY",
	"URBAN",
	"RESIDENTS_ONLY",
	"RESTRICTED_ACCESS",
	"VEHICLE_PROPERTY",
	"COMBINED_TRANSPORT",
	"SCHEDULE",
	"BLOCKED_ROAD_BY_INTERSECTION",
}

func (v *ViolationType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ViolationType(value)
	for _, existing := range AllowedViolationTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ViolationType", value)
}

// NewViolationTypeFromValue returns a pointer to a valid ViolationType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewViolationTypeFromValue(v string) (*ViolationType, error) {
	ev := ViolationType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ViolationType: valid values are %v", v, AllowedViolationTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ViolationType) IsValid() bool {
	for _, existing := range AllowedViolationTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ViolationType value
func (v ViolationType) Ptr() *ViolationType {
	return &v
}

type NullableViolationType struct {
	value *ViolationType
	isSet bool
}

func (v NullableViolationType) Get() *ViolationType {
	return v.value
}

func (v *NullableViolationType) Set(val *ViolationType) {
	v.value = val
	v.isSet = true
}

func (v NullableViolationType) IsSet() bool {
	return v.isSet
}

func (v *NullableViolationType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableViolationType(val *ViolationType) *NullableViolationType {
	return &NullableViolationType{value: val, isSet: true}
}

func (v NullableViolationType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableViolationType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

