/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.36
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the Warning type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Warning{}

// Warning struct for Warning
type Warning struct {
	// A human readable message that describes the warning.
	Description string `json:"description"`
	// A constant string that can be used to identify this warning class programmatically.  If additional information is available for a warningCode, it will be provided as key-value pairs with the parameter **details**. The keys available for a specific warningCode are documented directly with the warningCode. Unless stated otherwise, the values are of type string.  As an example, the following warningCode provides four key-value pairs in the **details**.  The keys are called **parameter**, **value**, **relatedParameter** and **relatedValue**. * `GENERAL_PARAMETER_IGNORED` - A parameter was ignored.   * `parameter` - The ignored parameter.   * `value` - The value of the ignored parameter.   * `relatedParameter` - The parameter which caused the parameter in question to be ignored.   * `relatedValue` - The value which caused the parameter in question to be ignored. Not present if the conflict is independent of the value.  Note that additional warningCode as well as the **details** of existing warningCode may be added at any time. Furthermore, the **description** may change at any time.  * `GENERAL_PARAMETER_IGNORED` - A parameter was ignored.   * `parameter` - The ignored parameter.   * `value` - The value of the ignored parameter.   * `relatedParameter` - The parameter which caused the parameter in question to be ignored.   * `relatedValue` - The value which caused the parameter in question to be ignored. Not present if the conflict is independent of the value. * `ROUTING_PARAMETER_INCONSISTENCY` - A parameter was inconsistent with other vehicle parameters. Some results like emissions or toll may not be correct.   * `parameter` - The inconsistent parameter.   * `value` - The value of the inconsistent parameter.   * `relatedParameter` - The parameter which caused the parameter in question to be inconsistent.   * `relatedValue` - The value which caused the parameter in question to be inconsistent. * `ROUTING_MISSING_VEHICLE_PARAMETER` - The requested vehicle contains a parameter which requires another parameter to be specified. Some results like emissions or toll may not be correct.   * `missingParameter` - The missing parameter.   * `relatedParameter` - The parameter which requires the missing parameter to be specified.   * `relatedValue` - The value which requires the missing parameter to be specified. * `ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE` - The requested language is not available for maneuvers, a different language is used instead.   * `requestedLanguage` - The language requested by the user.   * `usedLanguage` - The language of maneuvers in the response. * `ROUTING_UNSUPPORTED_EMISSION_PARAMETER` - The requested emission calculation method does not support the specified vehicle.   * `relatedParameter` - The parameter causing the emission calculation failure.   * `relatedValue` - The value of the related parameter. * `ROUTING_REGION_NOT_SUPPORTED_BY_EMISSION_STANDARD` - The requested emission calculation method does not support the region the profile was designed for.   * `region` - The requested region not supported by the requested emission calculation method.   * `supportedRegions` - The regions which are supported by the requested emission calculation method.   * `emissionStandard` - The requested emission calculation method. * `ROUTING_COUNTRY_IGNORED` - The country code given in **options[allowedCountries]** or **options[prohibitedCountries]** was ignored as it is not covered by the map.   * `ignoredCountryCode` - The ignored country code. * `ROUTING_SUBDIVISION_FALLBACK` - The country code given in **options[allowedCountries]** contains a country subdivision code that is not supported by the map, and that instead the enclosing country code was used. In such cases, routes are constrained to the country, rather than only the subdivision.   * `requestedSubdivisionCode` - The country subdivision code that was requested, but cannot be used.   * `fallbackCountryCode` - The enclosing country that is used as a fallback instead. * `ROUTING_LIVE_TRAFFIC_DATA_UNAVAILABLE` - Live traffic data are temporarily unavailable. * `ROUTING_ETC_SUBSCRIPTION_REQUIRED` - The route passes through toll areas but the configured vehicle does not contain the required electronic toll collection subscriptions.   * `requiredEtcSubscriptions` - The required electronic toll collection subscriptions. * `ROUTING_WAYPOINT_MATCH_DISTANCE` - The distance from the waypoint to the nearest accessible road is greater than 1000 meters. Closed areas, countries or roads can be the reason for this.   * `distance`- The air-line distance between waypoint and match point on the road.   * `parameter` - The waypoint parameter. * `ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED` - The combined-transport waypoint was ignored as no connection could be found.   * `parameter` - The waypoint parameter.   * `availableConnections` - The list of connections available for the start coordinates (array of strings). This will only be returned if connections for the start coordinates are found, but none match the destination coordinates. * `ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS` - The combined-transport waypoint was ambiguous.   * `parameter` - The waypoint parameter.   * `usedConnection` - The connection used for this route.   * `availableConnections` - The list of connections available for the combined-transport waypoint (array of strings). * `ROUTING_WAYPOINTS_DONT_MATCH_PROFILE_REGION` - The **waypoints** or the **routeId** do not match the region of the **profile** specified in the request.   * `waypointsRegion` - The region of the **waypoints** or **routeId**.   * `profileRegion` - The region of the profile. * `ROUTING_INACTIVE_ROADATTRIBUTE_SCENARIOS` - The scenarios given in **options[customRoadAttributeScenarios]** or the **routeId** contain at least one which is not active.   * `scenarios` - The inactive scenarioIds (comma-separated list). * `ROUTING_ROADATTRIBUTES_MAYBE_IGNORED` - At least one of the scenarios given in **options[customRoadAttributeScenarios]** or the **routeId** could not be fully considered in the route calculation after a map update, i.e. some road attributes may have been ignored.   * `scenarios` - The scenarios that may be ignored (comma-separated list). * `ROUTING_PARAMETER_VALUE_DEPRECATED` - The parameter value is deprecated.   * `parameter` - The deprecated parameter.   * `value` - The deprecated value. * `ROUTING_UPDATED_ROUTE_ID` - The requested **routeId** has been updated to a new map. * `ROUTING_RANGE_CALCULATION_FALLBACK` - A predefined profile is used with range calculation. Only vehicles models are officially supported for range calculation (evReport, evStatusEvents, evChargeEvents). As a fallback, a similar vehicle model has been used for the range calculation. Please consider using a vehicle model for this feature. * `ROUTING_STATE_OF_CHARGE_BELOW_MINIMUM` - The state of charge of the electric vehicle fell below the minimum defined in **evOptions[minimumStateOfCharge]** at least once. The calculated route may not be feasible. * `ROUTING_WEATHER_SERVICE_UNAVAILABLE` - The weather service is temporarily unavailable. A fallback to default weather was used for the consumption calculation. Please specify the weather explicitly, if this is not sufficient. * `ROUTING_WEATHER_FORECAST_UNAVAILABLE` - The weather forecast for at least one waypoint is unavailable because the time is too far in the future. A fallback to default weather is used for the consumption calculation if weather is unavailable for all waypoints. Please specify the weather explicitly, if this is not sufficient.   * `maximumDaysInFuture` - The maximum number of days the past, for which weather forecast is available. * `ROUTING_ELEVATIONS_UNAVAILABLE` - Elevations are unavailable for regions beyond -60° and +60° latitude.   * `results` - No elevations were considered when calculating these **results** for such parts of the route. 
	WarningCode string `json:"warningCode"`
	// Additional properties specific to this class of warnings.
	Details map[string]interface{} `json:"details,omitempty"`
}

type _Warning Warning

// NewWarning instantiates a new Warning object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewWarning(description string, warningCode string) *Warning {
	this := Warning{}
	this.Description = description
	this.WarningCode = warningCode
	return &this
}

// NewWarningWithDefaults instantiates a new Warning object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewWarningWithDefaults() *Warning {
	this := Warning{}
	return &this
}

// GetDescription returns the Description field value
func (o *Warning) GetDescription() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Description
}

// GetDescriptionOk returns a tuple with the Description field value
// and a boolean to check if the value has been set.
func (o *Warning) GetDescriptionOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Description, true
}

// SetDescription sets field value
func (o *Warning) SetDescription(v string) {
	o.Description = v
}

// GetWarningCode returns the WarningCode field value
func (o *Warning) GetWarningCode() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.WarningCode
}

// GetWarningCodeOk returns a tuple with the WarningCode field value
// and a boolean to check if the value has been set.
func (o *Warning) GetWarningCodeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.WarningCode, true
}

// SetWarningCode sets field value
func (o *Warning) SetWarningCode(v string) {
	o.WarningCode = v
}

// GetDetails returns the Details field value if set, zero value otherwise.
func (o *Warning) GetDetails() map[string]interface{} {
	if o == nil || IsNil(o.Details) {
		var ret map[string]interface{}
		return ret
	}
	return o.Details
}

// GetDetailsOk returns a tuple with the Details field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Warning) GetDetailsOk() (map[string]interface{}, bool) {
	if o == nil || IsNil(o.Details) {
		return map[string]interface{}{}, false
	}
	return o.Details, true
}

// HasDetails returns a boolean if a field has been set.
func (o *Warning) HasDetails() bool {
	if o != nil && !IsNil(o.Details) {
		return true
	}

	return false
}

// SetDetails gets a reference to the given map[string]interface{} and assigns it to the Details field.
func (o *Warning) SetDetails(v map[string]interface{}) {
	o.Details = v
}

func (o Warning) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Warning) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["description"] = o.Description
	toSerialize["warningCode"] = o.WarningCode
	if !IsNil(o.Details) {
		toSerialize["details"] = o.Details
	}
	return toSerialize, nil
}

func (o *Warning) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"description",
		"warningCode",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varWarning := _Warning{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varWarning)

	if err != nil {
		return err
	}

	*o = Warning(varWarning)

	return err
}

type NullableWarning struct {
	value *Warning
	isSet bool
}

func (v NullableWarning) Get() *Warning {
	return v.value
}

func (v *NullableWarning) Set(val *Warning) {
	v.value = val
	v.isSet = true
}

func (v NullableWarning) IsSet() bool {
	return v.isSet
}

func (v *NullableWarning) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableWarning(val *Warning) *NullableWarning {
	return &NullableWarning{value: val, isSet: true}
}

func (v NullableWarning) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableWarning) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


