/*
Routing

With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.

API version: 1.33
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow_routing

import (
	"encoding/json"
	"fmt"
)

// WorkingHoursPreset Enables the calculation of break and rest times according to the selected rules. Breaks and rests will be added to the **travelTime**, details can be requested through the _SCHEDULE_EVENTS_. For single day presets no schedule events of type _DAILY_REST_ will be returned. Only _VIOLATION_EVENTS_ will be returned when the maximum working time or maximum driving time is exceeded. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.   * `EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY` - Based on Regulation (EC) 561/2006 of the European Parliament and of the Council.   Break time 45 min, maximum driving time between breaks 4.5 hours, maximum driving time 9 hours, maximum travel time 13 hours.   * `EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY` - In contrast to `EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY`,   the exception rules \"Maximum driving time may be extended to 10h twice a week.\" and \"A daily rest may be reduced to 9h three times between weekly rests.\"   are observed in so far as the driving time limit is extended and the daily rest time is reduced.   * `EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY` - Based on Directive 2002/15/EC of the European Parliament and of the Council \"on the organisation of the working time of persons performing mobile road transport activities\".   Break time 30 min, maximum working time between breaks 6 hours, maximum travel time 9.5 hours.   * `EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY` - Makes sure that the standard rules of the EU directives 2003/88/EC and 2002/15/EC that are applicable for a route within a long single day are observed.   If working hours total more than 9h, a break must be 45min long. Here, a working time of at most 10h is guaranteed.   * `EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS ` - Based on Regulation (EC) 561/2006 of the European Parliament and of the Council.   Break time 45 min, maximum driving time between breaks 4.5 hours,   daily rest time 11 hours, maximum driving time between daily rests 9 hours, maximum travel time between daily rests 13 hours,   maximum driving time 56 hours, maximum travel time 144 hours.   * `EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS` - When two drivers form a team, they can take turns.   In contrast to `EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS`, no breaks are scheduled and the daily rest time limits are raised.   * `US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY` - Based on Hours of Service (HOS) of Drivers as issued by the Federal Motor Carrier Safety Administration (FMCSA).   Break time 30 min, maximum driving time between breaks 8 hours, maximum driving time 11 hours, maximum travel time 14 hours.   * `US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY` - Makes sure that the standard rules of the HOS regulations in 49 CFR 395 that are applicable for a route within a single day are observed.   It is assumed that the short-haul exception does apply so breaks are not scheduled.   * `US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS` - Based on Hours of Service (HOS) of Drivers as issued by the Federal Motor Carrier Safety Administration (FMCSA).   Break time 30 min, maximum driving time between breaks 8 hours,   daily rest time 10 hours, maximum driving time between daily rests 11 hours, maximum travel time between daily rests 14 hours.  If this parameter is given both as query parameter and in the body then it must match. Otherwise an error is returned.   For details see this [concept](./concepts/drivers-working-hours).
type WorkingHoursPreset string

// List of WorkingHoursPreset
const (
	EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY WorkingHoursPreset = "EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY"
	EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY WorkingHoursPreset = "EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY"
	EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY WorkingHoursPreset = "EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY"
	EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY WorkingHoursPreset = "EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY"
	EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS WorkingHoursPreset = "EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS"
	EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS WorkingHoursPreset = "EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS"
	US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY WorkingHoursPreset = "US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY"
	US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY WorkingHoursPreset = "US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY"
	US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS WorkingHoursPreset = "US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS"
)

// All allowed values of WorkingHoursPreset enum
var AllowedWorkingHoursPresetEnumValues = []WorkingHoursPreset{
	"EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY",
	"EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY",
	"EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY",
	"EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY",
	"EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS",
	"EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS",
	"US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY",
	"US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY",
	"US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS",
}

func (v *WorkingHoursPreset) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := WorkingHoursPreset(value)
	for _, existing := range AllowedWorkingHoursPresetEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid WorkingHoursPreset", value)
}

// NewWorkingHoursPresetFromValue returns a pointer to a valid WorkingHoursPreset
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewWorkingHoursPresetFromValue(v string) (*WorkingHoursPreset, error) {
	ev := WorkingHoursPreset(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for WorkingHoursPreset: valid values are %v", v, AllowedWorkingHoursPresetEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v WorkingHoursPreset) IsValid() bool {
	for _, existing := range AllowedWorkingHoursPresetEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to WorkingHoursPreset value
func (v WorkingHoursPreset) Ptr() *WorkingHoursPreset {
	return &v
}

type NullableWorkingHoursPreset struct {
	value *WorkingHoursPreset
	isSet bool
}

func (v NullableWorkingHoursPreset) Get() *WorkingHoursPreset {
	return v.value
}

func (v *NullableWorkingHoursPreset) Set(val *WorkingHoursPreset) {
	v.value = val
	v.isSet = true
}

func (v NullableWorkingHoursPreset) IsSet() bool {
	return v.isSet
}

func (v *NullableWorkingHoursPreset) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableWorkingHoursPreset(val *WorkingHoursPreset) *NullableWorkingHoursPreset {
	return &NullableWorkingHoursPreset{value: val, isSet: true}
}

func (v NullableWorkingHoursPreset) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableWorkingHoursPreset) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

